
#library "libc" libc
#import "math/constants.cte"
#import "math/circle.cte"

#foreign libc {
    #discardable
    printf :: fn (fmt: string, args: #cvargs ..any) -> i32

    #discardable
    sprintf :: fn (buf: *u8, fmt: string, args: #cvargs ..any) -> i32
}


min :: fn ($T: type, a: T, b: T) -> T {
  if a < b return a
  else return b
}

add : fn (i64) -> i64 : fn (foo: i64) -> i64 {
    return foo + 1
}

sub :: fn (foo: i64) -> i64 {
    return foo - 1
}

forExample :: fn () -> i64 {

    for i := 0; i < 5; i = i + 1 {
        printf("%d\n", i)
    }

    return 0
}

a : f64 = 5.0
b : i64 = 3
c := min(f64, a, 4)
d := min(i64, b, 4)
e := min(i64, b, d)

f := f64(b)

g : fn(i64) -> i64 = add

h := g(8)

g = sub

h = g(8)

i := circle.circumference(constants.tau)

// NOTE(vdka): The behaviour of being able to peer into an imported files imports
//  will go away
printf("Tau is %f\n", circle.constants.tau)

z := forExample()
addrA := &a
valA := <addrA

